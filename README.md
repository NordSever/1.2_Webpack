# Задание 1 - Webpack

**1-ый шаг** 
- git init
- npm install --save-dev, чтобы все указанные зависимости в уже созданном package.json установились в нашем локальном репозитории в папке node-modules.<br><br>

**2-ой шаг** Было бы разумным начать с того, чтобы посмотреть то, что у нас получается в браузере из того что есть.

Для этого нужен локальный веб-сервер. И у нас он уже установлен. Называется **webpack-dev-server.**

Этот пакет всё ещё очень популярен. Ведь у него есть набор всего необходимого для работы в режиме разработки. Он, как и полагается, "динамичный" сервер с поддержкой так называемого HMR (**шаги 3-4**), что позволяет мгновенно видеть в браузере изменения в коде (И ЧТО ВАЖНО без полной перезагрузки страницы). Мы каснёмся далее не только HMR, но и чего-то похожего ...(**шаг 5 "Я вовсе не <s> медведь</s> HMR"**). И рассмотрим какие неожиданные следствия они имеют **шаг 6 "Неожиданное открытие"**.

Однако, все его плюсы превращаются в минусы для сборки в режиме production. HMR - лишнее и отнимает ресурсы. Используемое виртуальное файловое дерево, где все пути разрешаются через механизм сборки(webpack  и его лодеры) могут замаскировать ошибки в путях.

 Добавим к этому, для краткости достаточно двух аргументов: он не минифицирует код, не кэширует данные... - т.е он в принципе не оптимизирован для production сборки.

 Короче, для проверки production нам нужен другой сервер. В задание нам предлагается live-server. Но он как минимум устарел: последняя версия — 1.2.2 от 2019 года. Мы выбрали статический сервер http-server. <br><br>

**3-ий шаг:**   
  Получившаяся сборка в папке dist (webpack --mode production) не имеет отдельного файла css. Так как стили при сборке записываются лоадером style-loader в JS-бандл.
  (Загружая готовый проект браузер выполняет js-код, изменяя DOM html-документа. И в конечном итоги, в dev-tools, мы видим внутри тега    \<head> тег \<style> с нашими стилями.) 

  Такой подход имеет преимущество в связке с HMR, так как позволяет менять стили в браузере автоматически без перезагрузки страницы (ведь стили как бы подключаемый js-модуль, что и нужно для  работы HMR). Эта функция крайне важна при разработке. 
  
  А вот у сборки production другие резоны.
  Ей нужен отдельный файл css. Прежде всего это вопрос производительности. Css-файл можно кэшировать, загружать параллельно с js-файлом, оптимизировать дополнительными плагинами.

  Очевидно было бы лучшим решением в режиме разработки использовать webpack-dev-server с  style-loader, а для сборки в режиме production вынести стили в файл, использовав плагин mini-css-extract-plugin.

   **ПОДКЛЮЧЕНИЕ**

Пропишем новые настройки в двух местах конфига, используя тернарный оператор:

**1-ая вставка**

        {
          test: /\.css$/i,
          use: [mode === 'production' ? MiniCssExtractPlugin.loader : 'style-loader', 'css-loader'],
        },

**2-ая вставка** Используем spread-оператор, т.к. массив plugins - null не примет

        plugins: [
      new HtmlWebPackPlugin({
        // ...код...
      }),
      ...(mode === 'production' ? [new MiniCssExtractPlugin()] : [] ),
    ]


**3-ий нюанс**
 Чтобы это работало нужно создать константу mode.

    const mode = argv.mode || 'production';

Значение argv.mode  автоматически передаётся Webpack при вызове из командной строки в функцию:

    module.exports = (env, argv) => {
    ...код...
  }


ВСЁ! Отдельный файл в dist cоздался. Можно проверять стили на динамичность.

**(проверка)** Закомментируем лишнее в соответствии с заданием в style.css. Мы сразу должны заметить изменения цвета текста.
  И проверим изменения в devTools: 
  
  Elements -->\<head> --> \<style>, 
  
  Console, 
  
  Source - добавляются *.hot-update.js 
  <br><br>

**4-ий шаг** Для связки с HMR **js-файлов** нужно добавить в entry-точку:

      if (module.hot) {
      module.hot.accept();
      }
  
   **(проверка)** Закомментируем лишнее в соответствии с заданием в **app.js**. 
  Проверим изменения в devTools:

  Console, 

  Source - добавляются *.hot-update.js <br><br>

  **5-ий шаг "Я вовсе не <s> медведь</s> HMR"**

Следующий логичный вопрос можно ли заставить HMR обновлять HTML? Технически — да, но с оговорками. Если HTML встроен в JS, то HMR сможет его обновить. Но этот вариант не подходит для обычного index.html, лежащего в папке как статический файл.

Но webpack-dev-server предлагает другой способ моментально обновлять изменения в html-файлах, правда дополнительно требуя подключения html-webpack-plugin, с минимальными настройками.

Пишем в конфиге:

    devServer: {
      watchFiles: ['src/index.html'],
      liveReload: true,
    }

ВАЖНО подчеркнуть:

HMR и liveReload — это разные механизмы. HMR пытается обновлять модули "на лету" (точечное обновление модулей без перезагрузки), а liveReload просто перезагружает всю страницу.

**(проверка)**

 Добавим \<span>Перезагрузка\</span>. Изменения отображаются моментально. <br><br>

**6-ой шаг "Неожиданное открытие"** 
Чтобы протестировать rules для статических файлах разных форматов изображений и шрифтов, нам нужно загрузить соответствующие файлы в src. Но в задании чётко оговоренн список файлов в этой папке. И там для них нет места, т.е. этот вопрос выходит за рамки задания. Поэтому мы рассмотрим данную часть ограничено. Ну и да, нам всё таки придётся как минимум загрузить три изображения для эксперимента.

**(эксперимент)** Закомментируем эти два rules. 

ПОСЛЕ загрузки webpack-dev-server мы загрузим три картинки в папку src/img.

Добавим:

- тег \<img> с первой картинкой в index.html
-  в style.css к body правило  background в виде второй картинке
- код в app.js импортирущий третью картинку через import и добавляющий её в body в виде тега \<img>

Первые два случае динамически отразятся в браузере, а третья нет.

Ту же картину мы наблюдаем и в сборки production.

И ВСЁ РАВНО. ЭТО неожиданный результат для меня, что файлы изображения автоматически подгружаются **ПОСЛЕ** запуска сервера без всяких rules.
<br><br>

Расскомментируем rules и тогда третий случай тоже заработает, то же динамически.

**ОДНАКО:** 
Правила rules нам нужны не только для загрузки, но и для возможности настройки, в том числе оптимизации.

Мы ограничимся примером:

    generator: {
      filename: 'images/[name][ext]'
    }

При production сборки он указывает нужную папку в dist, а также вместо "непонятного" названия первоначальное название.<br><br>

**7-ой шаг "Source map"** 

Без source map отладка сложна, так как код в бандле может быть: минифицирован, транспилирован. Для сборки режима production лучше скрывать **полный** исходный код, чтобы не показывать возможные уязвимости. Учтя рекомендации, я выбрал такую настройку:

    devtool: mode === 'production' ? 'nosources-source-map' : 'eval-source-map',

Посмотрите и дайте совет. Да я вижу появившуюся папку в Sources, .map файлы в dist, ... и т.д. но я толком не понимаю: так это должно быть или не так. Я слаб в отладке.<br><br>

**8-ой шаг "Babel"**

Привязка babel к webpack осуществляется при помощи добавления лоадера babel-loader в rules для .js-файлов. Там возможна и остальная настройка. Однако лучше вынести настройку в отдельный файл конфиг babel.config.json.

Первое, что нужно изменить в шаблоне - это установить (без флага --save-dev) core-js@3.22 (хотя это не самая свежая версия, но в избежание конфликтов мы все версии оставляем как указано).    

Возможным вариантом далее будет изменить свойство в конфиге "useBuiltIns" на "usage". Благодаря такой настройки параметра подключение библиотека core-js автоматически добавляет только нужные полифиллы и не требует явного экспорта в entry-файле как отдельного модуля . Но мы пойдём другим путём, максимально приближенным **к шаблону**. Оставим настройку "entry" и подключим библиотеку в ручную.

Тут важна **ПОСЛЕДОВАТЕЛЬНОСТЬ** import-ов в entry-точки.

**1-ым** import 'core-js/stable';

**2-ым** import './css/style.css';

**3-им** import './js/app';

Логика такая: 
- Полифиллы идут раньше основного js-кода, т.к. если они не успеют загрузится, код в старых браузерах сломается.
- Также важно, чтобы стили загрузились раньше кода (до отрисовки DOM). Главная причина: избежать визуальных артефактов (например, мигания нестилизованного контента). 
- Если поменять местами полифиллы (core-js) и CSS, то это не критично.<br><br>
  
**9-ий шаг "Удаление"** 

Можно удалить все файлы  из /src/js(в том числе папку \_\_test__), кроме app.js. Также зависимости jest, eslint и т.д. И соответствующие им скрипты. 